import{_ as e,c as i,o as l,a5 as o}from"./chunks/framework.yw-CZM5P.js";const f=JSON.parse('{"title":"Promise A+ 规范","description":"","frontmatter":{"title":"Promise A+ 规范","password":null,"date":"2024/10/02 02:06:04"},"headers":[],"relativePath":"blog/interview/javaScript/promiseAplus.md","filePath":"blog/interview/javaScript/promiseAplus.md","lastUpdated":1727806742000}'),r={name:"blog/interview/javaScript/promiseAplus.md"},t=o('<h1 id="promise-a-规范" tabindex="-1">Promise A+ 规范 <a class="header-anchor" href="#promise-a-规范" aria-label="Permalink to &quot;Promise A+ 规范&quot;">​</a></h1><h2 id="_1-术语" tabindex="-1">1. 术语 <a class="header-anchor" href="#_1-术语" aria-label="Permalink to &quot;1. 术语&quot;">​</a></h2><ul><li><strong>Promise</strong>: 一个包含了兼容 Promise 规范 then 方法的对象或函数。</li><li><strong>Thenable</strong>: 一个包含了 then 方法的对象或函数。</li><li><strong>Value</strong>: 任何 JavaScript 值（包括 undefined、thenable、promise 等）。</li><li><strong>Exception</strong>: 由 throw 表达式抛出来的值。</li><li><strong>Reason</strong>: 用于描述 Promise 被拒绝原因的值。</li></ul><h2 id="_2-要求" tabindex="-1">2. 要求 <a class="header-anchor" href="#_2-要求" aria-label="Permalink to &quot;2. 要求&quot;">​</a></h2><h3 id="_2-1-promise-状态" tabindex="-1">2.1 Promise 状态 <a class="header-anchor" href="#_2-1-promise-状态" aria-label="Permalink to &quot;2.1 Promise 状态&quot;">​</a></h3><p>一个 Promise 必须处在以下状态之一：</p><ul><li><p><strong>Pending</strong>:</p><ul><li>可以转换到 fulfilled 或 rejected 状态。</li></ul></li><li><p><strong>Fulfilled</strong>:</p><ul><li>不能转换成任何其它状态。</li><li>必须有一个值，且这个值不能被改变。</li></ul></li><li><p><strong>Rejected</strong>:</p><ul><li>不能转换成任何其它状态。</li><li>必须有一个原因，且这个值不能被改变。</li></ul></li></ul><p>“值不能被改变”指的是其 identity 不能被改变，而不是指其成员内容。</p><h3 id="_2-2-then-方法" tabindex="-1">2.2 then 方法 <a class="header-anchor" href="#_2-2-then-方法" aria-label="Permalink to &quot;2.2 then 方法&quot;">​</a></h3><p>一个 Promise 必须提供一个 then 方法来获取其值或原因。</p><h4 id="promise-的-then-方法接受两个参数" tabindex="-1">Promise 的 then 方法接受两个参数： <a class="header-anchor" href="#promise-的-then-方法接受两个参数" aria-label="Permalink to &quot;Promise 的 then 方法接受两个参数：&quot;">​</a></h4><p>promise.then(onFulfilled, onRejected);</p><ol><li><p><strong>onFulfilled 和 onRejected</strong> 都是可选参数：</p><ul><li>a. 如果 onFulfilled 不是一个函数，则忽略之。</li><li>b. 如果 onRejected 不是一个函数，则忽略之。</li></ul></li><li><p>如果 onFulfilled 是一个函数：</p><ul><li>a. 它必须在 promise fulfilled 后调用，且 promise 的 value 为其第一个参数。</li><li>b. 它不能在 promise fulfilled 前调用。</li><li>c. 不能被多次调用。</li></ul></li><li><p>如果 onRejected 是一个函数：</p><ul><li>a. 它必须在 promise rejected 后调用，且 promise 的 reason 为其第一个参数。</li><li>b. 它不能在 promise rejected 前调用。</li><li>c. 不能被多次调用。</li></ul></li><li><p>onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行。</p></li><li><p>onFulfilled 和 onRejected 必须被当做函数调用（即函数体内的 this 为 undefined）。</p></li><li><p>对于一个 promise，它的 then 方法可以调用多次：</p><ul><li>a. 当 promise fulfilled 后，所有 onFulfilled 都必须按照其注册顺序执行。</li><li>b. 当 promise rejected 后，所有 onRejected 都必须按照其注册顺序执行。</li></ul></li><li><p>then 必须返回一个 promise： promise2 = promise1.then(onFulfilled, onRejected);</p><ul><li>a. 如果 onFulfilled 或 onRejected 返回了值 x，则执行 Promise 解析流程 [[Resolve]](promise2, x)。</li><li>b. 如果 onFulfilled 或 onRejected 抛出了异常 e，则 promise2 应当以 e 为 reason 被拒绝。</li><li>c. 如果 onFulfilled 不是一个函数且 promise1 已经 fulfilled，则 promise2 必须以 promise1 的值 fulfilled。</li><li>d. 如果 onRejected 不是一个函数且 promise1 已经 rejected，则 promise2 必须以相同的 reason 被拒绝。</li></ul></li></ol><h3 id="_2-3-promise-解析过程" tabindex="-1">2.3 Promise 解析过程 <a class="header-anchor" href="#_2-3-promise-解析过程" aria-label="Permalink to &quot;2.3 Promise 解析过程&quot;">​</a></h3><p>Promise 解析过程是以一个 promise 和一个值作为参数的抽象过程，表示为 [[Resolve]](promise, x)。过程如下：</p><ol><li><p>如果 promise 和 x 指向相同的值，使用 TypeError 作为原因将 promise 拒绝。</p></li><li><p>如果 x 是一个 promise，采用其状态：</p><ul><li>a. 如果 x 是 pending 状态，promise 必须保持 pending，走到 x fulfilled 或 rejected。</li><li>b. 如果 x 是 fulfilled 状态，将 x 的值用于 fulfill promise。</li><li>c. 如果 x 是 rejected 状态，将 x 的原因用于 reject promise。</li></ul></li><li><p>如果 x 是一个对象或一个函数：</p><ul><li>a. 将 then 赋为 x.then。</li><li>b. 如果在取 x.then 值时抛出了异常，则以这个异常作为原因将 promise 拒绝。</li><li>c. 如果 then 是一个函数，以 x 为 this 调用 then 函数，且第一个参数是 resolvePromise，第二个参数是 rejectPromise，且： <ul><li>i. 当 resolvePromise 被以 y 为参数调用，执行 [[Resolve]](promise, y)。</li><li>ii. 当 rejectPromise 被以 r 为参数调用，则以 r 为原因将 promise 拒绝。</li><li>iii. 如果 resolvePromise 和 rejectPromise 都被调用了，或者被调用了多次，则只第一次有效，后面的忽略。</li><li>iv. 如果在调用 then 时抛出了异常，则： <ul><li><ol><li>如果 resolvePromise 或 rejectPromise 已经被调用了，则忽略它。</li></ol></li><li><ol start="2"><li>否则，以 e 为 reason 将 promise 拒绝。</li></ol></li></ul></li></ul></li></ul></li><li><p>如果 then 不是一个函数，则以 x 为值 fulfill promise。</p></li><li><p>如果 x 不是对象也不是函数，则以 x 为值 fulfill promise。</p></li></ol>',16),s=[t];function n(a,p,m,d,u,c){return l(),i("div",null,s)}const P=e(r,[["render",n]]);export{f as __pageData,P as default};
